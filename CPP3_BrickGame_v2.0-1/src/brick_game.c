#include "brick_game/tetris/backend_tetris.h"
#include "gui/cli/frontend.h"

void gameLoop();

// Функция main — точка входа в программу.
int main() {
  initNcurses();  // Инициализирует библиотеку ncurses для работы с графикой в
                  // терминале.
  initColors();  // Инициализирует цветовые схемы для отображения элементов
                 // игры.
  initGame();  // Инициализирует начальное состояние игры (генерация поля, фигур
               // и установка параметров).
  gameLoop();  // Запускает основной цикл игры (где обрабатывается игровой
               // процесс).

  endwin();  // Возвращает терминал в нормальное состояние после завершения
             // работы программы.

  return 0;  // Возвращает 0, сигнализируя о нормальном завершении программы.
}

// Основной цикл игры
void gameLoop() {
  bool is_playing = true;  // Флаг, указывающий, продолжается ли игра.
  GameState_t *gs = getGameState();  // Получаем текущее состояние игры.
  while (is_playing) {  // Цикл продолжается, пока игра активна.

    // GameState_t *gs = getGameState();  // Получаем текущее состояние игры.

    // Обновляем текущее состояние игры для отображения.
    GameInfo_t gi = updateCurrentState(gs);

    int ch = getch();  // Получаем ввод от пользователя (нажатие клавиши).

    // Отрисовываем интерфейс игры на основе состояния.
    render(gs->status, gs->win, gi);

    // Освобождаем ресурсы, связанные с отображением информации.
    freeGameInfo(&gi);

    // Проверка на завершение игры
    if (gs->status == GameOver ||
        gs->win) {  // Если игра завершена (проигрыш или победа).
      while (ch != KEY_ENTER && ch != '\n' && ch != 'q' && ch != KEY_ESC)
        ch = getch();  // Ожидаем рестарта или выхода.
      initGame();  // Инициализируем игру заново, если выбрано ENTER.
    }

    timeout(10);  // Устанавливаем таймаут на 10 миллисекунд для функции getch()
                  // (неблокирующий режим).

    userInput(gs, getUserAction(ch));  // Обрабатываем действия пользователя на
                                       // основе нажатой клавиши.
    is_playing = gs->is_playing;  // Проверяем, продолжается ли игра (может быть
                                  // завершена пользователем).
  }
}
