#include "../s21_decimal.h"

int s21_truncate(s21_decimal value, s21_decimal *result) {
  // Если указатель на результат равен NULL, возвращаем ошибку (1)
  if (result == NULL) return 1;

  // Определяем константу 'ten', которая используется для деления числа в
  // процессе
  const s21_w_dec ten = {{10, 0, 0, 0, 0, 0}, 0, 0};

  // Инициализируем 'divisor' как единицу; это будет наш делитель
  s21_w_dec divisor = {{1, 0, 0, 0, 0, 0}, 0, 0};

  // Преобразуем входной decimal в расширенный формат для удобства операций
  s21_w_dec val = dec_to_wdec(value);

  // Инициализируем переменные для хранения флага ошибки и знака числа
  int ret = 0, sig = val.sig;

  // Если значение имеет ненулевую экспоненту (т.е. число имеет дробную часть)
  if (val.exp) {
    // Цикл умножает делитель на 10 столько раз, сколько указано в экспоненте
    // Это делается для того, чтобы привести делитель к масштабу дробной части
    // числа
    for (int i = 0; i < val.exp; i++) {
      divisor = wdec_mul(divisor, ten);
    }

    // Делим исходное число на этот делитель, чтобы убрать дробную часть
    s21_w_dec res = wdec_div(val, divisor);

    // После деления устанавливаем экспоненту в 0, так как число теперь целое
    res.exp = 0;

    // Сохраняем знак числа
    res.sig = sig;

    // Проверяем, можно ли преобразовать результат в s21_decimal
    ret = check_rew_trans(res);

    // Если проверка успешна, преобразуем расширенное число обратно в
    // s21_decimal
    if (!ret) {
      *result = wdec_to_dec(res);
    } else {
      ret = 1;  // Если преобразование невозможно, возвращаем ошибку
    }
  } else {
    // Если экспонента была нулевой (т.е. число уже целое), просто копируем
    // значение
    *result = value;
  }

  return ret;  // Возвращаем код ошибки (0, если все прошло успешно)
}
