Давайте рассмотрим, как работает функция `get_bit`, с конкретными примерами и итерациями.

### Функция `get_bit`

```c
int get_bit(const s21_w_dec decimal, const int bnum) {
  return (decimal.bits[bnum / IBS] & _2(bnum % IBS)) != 0;
}
```

#### Что делает функция:

Функция `get_bit` возвращает значение конкретного бита (0 или 1) в числе, представленном структурой `s21_w_dec`. 

- **Параметры:**
  - `decimal` — структура `s21_w_dec`, содержащая массив `bits` из 6 элементов типа `unsigned int`.
  - `bnum` — номер бита, который мы хотим проверить.

#### Как работает функция:

1. **`bnum / IBS`:** Вычисляется индекс элемента массива `bits`, который содержит интересующий нас бит. `IBS` (Int Bit Size) — это количество битов в одном `int`. Обычно это 32.
   
2. **`bnum % IBS`:** Вычисляется номер бита внутри выбранного элемента массива.

3. **`_2(bnum % IBS)`:** Макрос `_2(bit)` создает битовую маску, сдвигая 1 на нужное количество позиций влево. Это позволяет изолировать конкретный бит в выбранном элементе массива `bits`.

4. **`decimal.bits[bnum / IBS] & _2(bnum % IBS)`:** Выполняется операция побитового И (AND) между значением выбранного элемента массива и битовой маской. Если интересующий нас бит равен 1, результат будет ненулевым. Если бит равен 0, результат будет равен 0.

5. **`!= 0`:** Преобразует результат в логическое значение: 1 (если бит равен 1) или 0 (если бит равен 0).

### Пример с итерациями

Рассмотрим пример с конкретным числом, чтобы понять, как работает функция.

Предположим, у нас есть следующая структура `s21_w_dec`:

```c
s21_w_dec decimal = {
    {0b11001100, 0b10101010, 0b11110000, 0b00001111, 0b00110011, 0b01010101},
    0,
    0
};
```

- Здесь массив `bits` содержит 6 элементов, каждый из которых — 32-битное целое число. Мы будем использовать 8-битные числа для простоты, хотя на практике числа будут 32-битными.

Допустим, мы хотим получить значение бита с номером `bnum = 18`.

#### Шаги:

1. **Вычисляем `bnum / IBS`:**

   - `IBS = 8` (в данном примере, но в реальной программе это будет 32).
   - `bnum = 18`.
   - `18 / 8 = 2` — это индекс элемента в массиве `bits`, который содержит бит с номером 18.
   - Мы обращаемся к элементу `decimal.bits[2]`, который равен `0b11110000`.

2. **Вычисляем `bnum % IBS`:**

   - `18 % 8 = 2` — это позиция интересующего нас бита внутри выбранного элемента массива.

3. **Вычисляем битовую маску `_2(bnum % IBS)` (то есть `_2(2)`):**

   - `_2(2)` означает сдвинуть 1 на 2 позиции влево: `0b00000100`.

4. **Применяем побитовое И (`&`) между `decimal.bits[2]` и битовой маской:**

   - `0b11110000 & 0b00000100 = 0b00000000`.

5. **Результат сравнивается с 0:**

   - `0b00000000 != 0` равно `0` (ложь).

Это означает, что бит с номером `18` равен 0.

### Другой пример с `bnum = 9`:

1. **Вычисляем `bnum / IBS`:**

   - `9 / 8 = 1`.
   - Мы обращаемся к элементу `decimal.bits[1]`, который равен `0b10101010`.

2. **Вычисляем `bnum % IBS`:**

   - `9 % 8 = 1`.

3. **Вычисляем битовую маску `_2(bnum % IBS)` (то есть `_2(1)`):**

   - `_2(1)` означает сдвинуть 1 на 1 позицию влево: `0b00000010`.

4. **Применяем побитовое И (`&`) между `decimal.bits[1]` и битовой маской:**

   - `0b10101010 & 0b00000010 = 0b00000010`.

5. **Результат сравнивается с 0:**

   - `0b00000010 != 0` равно `1` (истина).

Это означает, что бит с номером `9` равен 1.

### Итог

Функция `get_bit` позволяет узнать значение конкретного бита в массиве `bits` структуры `s21_w_dec`, где бит выбирается по его порядковому номеру `bnum`. Функция разбивает номер бита на индекс элемента массива и позицию бита внутри этого элемента, затем использует маску для изоляции нужного бита и проверяет его значение.

Конечно! Давайте разберем остальные функции так же подробно, как мы разобрали `get_bit`. Каждую функцию будем рассматривать с примером, чтобы понять, как она работает.

### Функция `set_bit`

```c
s21_w_dec set_bit(s21_w_dec decimal, const int bnum) {
  decimal.bits[bnum / IBS] |= _2(bnum % IBS);
  return decimal;
}
```

#### Что делает функция:

Функция `set_bit` устанавливает (делает равным 1) определенный бит в числе `s21_w_dec`.

- **Параметры:**
  - `decimal` — структура `s21_w_dec`, содержащая массив `bits` из 6 элементов типа `unsigned int`.
  - `bnum` — номер бита, который мы хотим установить в 1.

#### Как работает функция:

1. **`bnum / IBS`:** Определяет индекс элемента массива `bits`, в котором находится нужный бит.
   
2. **`bnum % IBS`:** Определяет позицию бита внутри этого элемента массива.

3. **`_2(bnum % IBS)`:** Создает битовую маску, сдвигая 1 на нужное количество позиций влево.

4. **`|= _2(bnum % IBS)`:** Применяет побитовое ИЛИ (OR) между текущим значением элемента массива `bits` и битовой маской. Это устанавливает соответствующий бит в 1, независимо от его предыдущего значения.

5. **Возвращает измененную структуру `decimal`.**

### Пример с итерациями

Предположим, у нас есть структура `s21_w_dec`:

```c
s21_w_dec decimal = {
    {0b11001100, 0b10101010, 0b11110000, 0b00001111, 0b00110011, 0b01010101},
    0,
    0
};
```

Допустим, мы хотим установить бит с номером `bnum = 18` в 1.

#### Шаги:

1. **Вычисляем `bnum / IBS`:**

   - `IBS = 8` (для простоты примера, хотя в реальности это 32).
   - `bnum = 18`.
   - `18 / 8 = 2` — значит, нужный бит находится в элементе `decimal.bits[2]`, который равен `0b11110000`.

2. **Вычисляем `bnum % IBS`:**

   - `18 % 8 = 2` — это позиция бита внутри выбранного элемента массива.

3. **Вычисляем битовую маску `_2(bnum % IBS)` (то есть `_2(2)`):**

   - `_2(2)` означает сдвинуть 1 на 2 позиции влево: `0b00000100`.

4. **Применяем побитовое ИЛИ (`|=`) между `decimal.bits[2]` и битовой маской:**

   - `0b11110000 | 0b00000100 = 0b11110100`.

Теперь в элементе `decimal.bits[2]` бит с номером `2` установлен в 1.

Результат:

```c
decimal.bits[2] = 0b11110100;
```

### Функция `reset_bit`

```c
s21_w_dec reset_bit(s21_w_dec decimal, const int bnum) {
  decimal.bits[bnum / IBS] &= ~(_2(bnum % IBS));
  return decimal;
}
```

#### Что делает функция:

Функция `reset_bit` сбрасывает (делает равным 0) определенный бит в числе `s21_w_dec`.

- **Параметры:**
  - `decimal` — структура `s21_w_dec`, содержащая массив `bits` из 6 элементов типа `unsigned int`.
  - `bnum` — номер бита, который мы хотим сбросить в 0.

#### Как работает функция:

1. **`bnum / IBS`:** Определяет индекс элемента массива `bits`, в котором находится нужный бит.
   
2. **`bnum % IBS`:** Определяет позицию бита внутри этого элемента массива.

3. **`_2(bnum % IBS)`:** Создает битовую маску, сдвигая 1 на нужное количество позиций влево.

4. **`~(_2(bnum % IBS))`:** Инвертирует битовую маску. Теперь вместо одного бита, равного 1, у нас маска, где этот бит равен 0, а все остальные — 1.

5. **`&= ~(_2(bnum % IBS))`:** Применяет побитовое И (AND) между текущим значением элемента массива `bits` и инвертированной битовой маской. Это сбрасывает соответствующий бит в 0, не изменяя другие биты.

6. **Возвращает измененную структуру `decimal`.**

### Пример с итерациями

Возьмем ту же структуру `s21_w_dec`, что и в предыдущем примере:

```c
s21_w_dec decimal = {
    {0b11001100, 0b10101010, 0b11110100, 0b00001111, 0b00110011, 0b01010101},
    0,
    0
};
```

Допустим, мы хотим сбросить бит с номером `bnum = 18`.

#### Шаги:

1. **Вычисляем `bnum / IBS`:**

   - `IBS = 8` (для простоты примера).
   - `bnum = 18`.
   - `18 / 8 = 2` — значит, нужный бит находится в элементе `decimal.bits[2]`, который равен `0b11110100`.

2. **Вычисляем `bnum % IBS`:**

   - `18 % 8 = 2` — это позиция бита внутри выбранного элемента массива.

3. **Вычисляем битовую маску `_2(bnum % IBS)` (то есть `_2(2)`):**

   - `_2(2)` означает сдвинуть 1 на 2 позиции влево: `0b00000100`.

4. **Инвертируем битовую маску `~(_2(bnum % IBS))`:**

   - `~0b00000100 = 0b11111011`.

5. **Применяем побитовое И (`&=`) между `decimal.bits[2]` и инвертированной маской:**

   - `0b11110100 & 0b11111011 = 0b11110000`.

Теперь в элементе `decimal.bits[2]` бит с номером `2` сброшен в 0.

Результат:

```c
decimal.bits[2] = 0b11110000;
```

### Функция `shift_l`

```c
s21_w_dec shift_l(s21_w_dec decimal) {
  for (int i = 5; i >= 0; i--) {
    decimal.bits[i] = decimal.bits[i] << 1;
    if (i) {
      if ((decimal.bits[i - 1] & _2(31)) != 0) decimal.bits[i] |= _2(0);
    }
  }
  return decimal;
}
```

#### Что делает функция:

Функция `shift_l` сдвигает все биты числа `s21_w_dec` влево на одну позицию (умножает число на 2), учитывая перенос бита из одного элемента массива `bits` в следующий.

- **Параметры:**
  - `decimal` — структура `s21_w_dec`, содержащая массив `bits` из 6 элементов типа `unsigned int`.

#### Как работает функция:

1. **Проходим по массиву `bits` с конца (i = 5) до начала (i = 0).**
   
2. **Сдвигаем текущий элемент `decimal.bits[i]` влево на одну позицию (`<< 1`).**
   
3. **Если текущий элемент не первый (`i > 0`), проверяем, был ли установлен 31-й бит в предыдущем элементе `decimal.bits[i-1]` (то есть самый левый бит).**
   
4. **Если 31-й бит был установлен (`!= 0`), то устанавливаем 0-й бит в текущем элементе (`decimal.bits[i] |= _2(0)`), чтобы перенести его.**

5. **Возвращаем измененную структуру `decimal`.**

### Пример с итерациями

Допустим, у нас есть структура `s21_w_dec`:

```c
s21_w_dec decimal = {
    {0b01010101, 0b00110011, 0b00001111, 0b11110000, 0b10101010, 0b11001100},
    0,
    0
};
```

Мы хотим сдвинуть все биты влево на одну позицию.

#### Шаги:

1. **Сначала сдвигаем последний элемент `decimal.bits[5]`:**

   - `0b11001100 << 1 = 

0b10011000`.
   - `decimal.bits[5]` теперь равен `0b10011000`.

2. **Сдвигаем элемент `decimal.bits[4]`:**

   - `0b10101010 << 1 = 0b01010100`.
   - Но мы проверяем 31-й бит в `decimal.bits[5]` (его предыдущем элементе):
     - В `decimal.bits[5] = 0b11001100` 31-й бит не установлен, так что добавлять ничего не нужно.
   - `decimal.bits[4]` остается равным `0b01010100`.

3. **Сдвигаем элемент `decimal.bits[3]`:**

   - `0b11110000 << 1 = 0b11100000`.
   - Проверяем 31-й бит в `decimal.bits[4]`:
     - В `decimal.bits[4] = 0b10101010` 31-й бит не установлен.
   - `decimal.bits[3]` остается равным `0b11100000`.

4. **Повторяем процесс для всех элементов массива:**

Результат после всех сдвигов:

```c
decimal.bits[5] = 0b10011000;
decimal.bits[4] = 0b01010100;
decimal.bits[3] = 0b11100000;
decimal.bits[2] = 0b00011110;
decimal.bits[1] = 0b01100110;
decimal.bits[0] = 0b10101010;
```

### Функция `shift_r`

```c
s21_w_dec shift_r(s21_w_dec decimal) {
  for (int i = 0; i < 6; i++) {
    decimal.bits[i] = decimal.bits[i] >> 1;
    if (i < 5) {
      if ((decimal.bits[i + 1] & _2(0)) != 0) decimal.bits[i] |= _2(31);
    }
  }
  return decimal;
}
```

#### Что делает функция:

Функция `shift_r` сдвигает все биты числа `s21_w_dec` вправо на одну позицию (делит число на 2), учитывая перенос бита из одного элемента массива `bits` в предыдущий.

- **Параметры:**
  - `decimal` — структура `s21_w_dec`, содержащая массив `bits` из 6 элементов типа `unsigned int`.

#### Как работает функция:

1. **Проходим по массиву `bits` с начала (i = 0) до конца (i = 5).**
   
2. **Сдвигаем текущий элемент `decimal.bits[i]` вправо на одну позицию (`>> 1`).**
   
3. **Если текущий элемент не последний (`i < 5`), проверяем, был ли установлен 0-й бит в следующем элементе `decimal.bits[i+1]` (то есть самый правый бит).**
   
4. **Если 0-й бит был установлен (`!= 0`), то устанавливаем 31-й бит в текущем элементе (`decimal.bits[i] |= _2(31)`), чтобы перенести его.**

5. **Возвращаем измененную структуру `decimal`.**

### Пример с итерациями

Возьмем ту же структуру `s21_w_dec`:

```c
s21_w_dec decimal = {
    {0b10101010, 0b00110011, 0b00001111, 0b11110000, 0b10101010, 0b11001100},
    0,
    0
};
```

Мы хотим сдвинуть все биты вправо на одну позицию.

#### Шаги:

1. **Сначала сдвигаем первый элемент `decimal.bits[0]`:**

   - `0b10101010 >> 1 = 0b01010101`.
   - `decimal.bits[0]` теперь равен `0b01010101`.

2. **Сдвигаем элемент `decimal.bits[1]`:**

   - `0b00110011 >> 1 = 0b00011001`.
   - Но мы проверяем 0-й бит в `decimal.bits[2]` (его следующем элементе):
     - В `decimal.bits[2] = 0b00001111` 0-й бит установлен, поэтому мы добавляем его в 31-й бит текущего элемента: `0b10011001`.
   - `decimal.bits[1]` теперь равен `0b10011001`.

3. **Повторяем процесс для всех элементов массива:**

Результат после всех сдвигов:

```c
decimal.bits[0] = 0b01010101;
decimal.bits[1] = 0b10011001;
decimal.bits[2] = 0b00000111;
decimal.bits[3] = 0b01111000;
decimal.bits[4] = 0b01010101;
decimal.bits[5] = 0b01100110;
```

### Функция `wdec_sum`

```c
s21_w_dec wdec_sum(const s21_w_dec dec1, const s21_w_dec dec2) {
  s21_w_dec tmp = {{0, 0, 0, 0, 0, 0}, 0, 0};
  int overflow = 0;
  for (int i = 0; i < BL; i++) {
    int b_dec1 = get_bit(dec1, i);
    int b_dec2 = get_bit(dec2, i);
    if (overflow) {
      if (b_dec1 && b_dec2) {
        tmp = set_bit(tmp, i);
      } else if (!b_dec1 && !b_dec2) {
        tmp = set_bit(tmp, i);
        overflow = 0;
      }
    } else {
      if (b_dec1 && b_dec2) {
        overflow = 1;
      } else if (!b_dec1 && !b_dec2) {
        ;
      } else
        tmp = set_bit(tmp, i);
    }
  }
  return tmp;
}
```

#### Что делает функция:

Функция `wdec_sum` выполняет побитовую сумму двух чисел `s21_w_dec`, учитывая возможное переполнение (перенос).

- **Параметры:**
  - `dec1` и `dec2` — структуры `s21_w_dec`, которые нужно сложить.

#### Как работает функция:

1. **Инициализируем временную структуру `tmp` с нулями, которая будет содержать результат сложения.**
   
2. **Проходим по всем битам от 0 до `BL-1` (где `BL` — общее количество битов в `s21_w_dec`, обычно 192).**

3. **Для каждого бита:**
   
   - Получаем значение текущего бита из обоих чисел с помощью функции `get_bit`.
   - Если оба бита равны 1:
     - Если есть `overflow`, устанавливаем бит результата в 1.
     - Если нет `overflow`, просто устанавливаем `overflow` в 1, а бит результата не трогаем (он остается 0).
   - Если оба бита равны 0:
     - Если есть `overflow`, устанавливаем бит результата в 1 и сбрасываем `overflow`.
   - Если один бит равен 1, а другой 0:
     - Если есть `overflow`, оставляем бит результата равным 0 и не трогаем `overflow`.
     - Если нет `overflow`, устанавливаем бит результата в 1.

4. **Возвращаем структуру `tmp`, содержащую результат сложения.**

### Пример с итерациями

Допустим, у нас есть две структуры `s21_w_dec`:

```c
s21_w_dec dec1 = {
    {0b10101010, 0b00000001, 0b00000000, 0b00000000, 0b00000000, 0b00000000},
    0,
    0
};
s21_w_dec dec2 = {
    {0b01010101, 0b00000001, 0b00000000, 0b00000000, 0b00000000, 0b00000000},
    0,
    0
};
```

Мы хотим сложить `dec1` и `dec2`.

#### Шаги:

1. **Инициализируем `tmp` с нулями.**

2. **Проходим по всем битам:**

   - Для `i = 0` (первый бит):
     - `b_dec1 = 0`, `b_dec2 = 1`, `overflow = 0`.
     - `tmp = set_bit(tmp, 0)`, теперь `tmp.bits[0] = 0b00000001`.

   - Для `i = 1` (второй бит):
     - `b_dec1 = 1`, `b_dec2 = 0`, `overflow = 0`.
     - `tmp = set_bit(tmp, 1)`, теперь `tmp.bits[0] = 0b00000011`.

   - Для `i = 2` (третий бит):
     - `b_dec1 = 0`, `b_dec2 = 1`, `overflow = 0`.
     -

 `tmp = set_bit(tmp, 2)`, теперь `tmp.bits[0] = 0b00000111`.

   - Для `i = 7` (восьмой бит):
     - `b_dec1 = 1`, `b_dec2 = 1`, `overflow = 0`.
     - Устанавливаем `overflow = 1`, не трогаем бит.

   - Для `i = 8` (девятый бит):
     - `b_dec1 = 0`, `b_dec2 = 0`, `overflow = 1`.
     - Устанавливаем `tmp.bits[1] = 0b00000001` и сбрасываем `overflow`.

Результат после всех итераций:

```c
tmp.bits[0] = 0b00000011;
tmp.bits[1] = 0b00000001;
```

Это был результат сложения двух чисел, содержащих как единичные, так и нулевые биты, с учетом переноса бита.

### Функция `wdec_sub`

```c
s21_w_dec wdec_sub(const s21_w_dec dec1, const s21_w_dec dec2) {
  s21_w_dec tmp = {{0, 0, 0, 0, 0, 0}, 0, 0};
  int loan = 0;
  for (int i = 0; i < BL; i++) {
    int b_dec1 = get_bit(dec1, i);
    int b_dec2 = get_bit(dec2, i);
    if (loan) {
      if (b_dec1 && !b_dec2) {
        loan = 0;
      } else if ((!b_dec1 && !b_dec2) || (b_dec1 && b_dec2)) {
        tmp = set_bit(tmp, i);
      }
    } else {
      if (b_dec1 && !b_dec2) {
        tmp = set_bit(tmp, i);
      } else if (!b_dec1 && b_dec2) {
        tmp = set_bit(tmp, i);
        loan = 1;
      }
    }
  }
  return tmp;
}
```

#### Что делает функция:

Функция `wdec_sub` выполняет побитовое вычитание одного числа `s21_w_dec` из другого, учитывая возможное заимствование (loan).

- **Параметры:**
  - `dec1` — уменьшаемое число.
  - `dec2` — вычитаемое число.

#### Как работает функция:

1. **Инициализируем временную структуру `tmp` с нулями, которая будет содержать результат вычитания.**
   
2. **Проходим по всем битам от 0 до `BL-1`.**

3. **Для каждого бита:**
   
   - Получаем значение текущего бита из обоих чисел с помощью функции `get_bit`.
   - Если есть заимствование (`loan`):
     - Если `b_dec1` равен 1, а `b_dec2` равен 0, сбрасываем `loan`.
     - Если оба бита равны 0 или оба равны 1, устанавливаем бит результата в 1.
   - Если нет заимствования:
     - Если `b_dec1` равен 1, а `b_dec2` равен 0, устанавливаем бит результата в 1.
     - Если `b_dec1` равен 0, а `b_dec2` равен 1, устанавливаем бит результата в 1 и включаем заимствование.

4. **Возвращаем структуру `tmp`, содержащую результат вычитания.**

### Пример с итерациями

Допустим, у нас есть две структуры `s21_w_dec`:

```c
s21_w_dec dec1 = {
    {0b10101010, 0b00000001, 0b00000000, 0b00000000, 0b00000000, 0b00000000},
    0,
    0
};
s21_w_dec dec2 = {
    {0b01010101, 0b00000001, 0b00000000, 0b00000000, 0b00000000, 0b00000000},
    0,
    0
};
```

Мы хотим вычесть `dec2` из `dec1`.

#### Шаги:

1. **Инициализируем `tmp` с нулями.**

2. **Проходим по всем битам:**

   - Для `i = 0` (первый бит):
     - `b_dec1 = 0`, `b_dec2 = 1`, `loan = 0`.
     - Устанавливаем `tmp = set_bit(tmp, 0)`, теперь `tmp.bits[0] = 0b00000001`.
     - Включаем `loan`.

   - Для `i = 1` (второй бит):
     - `b_dec1 = 1`, `b_dec2 = 0`, `loan = 1`.
     - Сбрасываем `loan`, не трогаем бит.

   - Для `i = 2` (третий бит):
     - `b_dec1 = 0`, `b_dec2 = 1`, `loan = 0`.
     - Устанавливаем `tmp = set_bit(tmp, 2)`, теперь `tmp.bits[0] = 0b00000101`.
     - Включаем `loan`.

   - Для `i = 7` (восьмой бит):
     - `b_dec1 = 1`, `b_dec2 = 0`, `loan = 1`.
     - Сбрасываем `loan`, устанавливаем `tmp.bits[0] = 0b10100001`.

Результат после всех итераций:

```c
tmp.bits[0] = 0b10100001;
```

Это был результат вычитания двух чисел, содержащих как единичные, так и нулевые биты, с учетом заимствования бита.

### Функция `wdec_mul`

```c
s21_w_dec wdec_mul(const s21_w_dec dec1, const s21_w_dec dec2) {
  s21_w_dec tmp = {{0, 0, 0, 0, 0, 0}, 0, 0};
  s21_w_dec mult = dec1;
  for (int i = 0; i < BL / 2; i++) {
    if (get_bit(dec2, i)) tmp = wdec_sum(tmp, mult);
    mult = shift_l(mult);
  }
  return tmp;
}
```

#### Что делает функция:

Функция `wdec_mul` умножает два числа `s21_w_dec`.

- **Параметры:**
  - `dec1` и `dec2` — структуры `s21_w_dec`, которые нужно умножить.

#### Как работает функция:

1. **Инициализируем временную структуру `tmp` с нулями, которая будет содержать результат умножения.**
   
2. **Проходим по каждому биту второго числа `dec2` до `BL/2` (где `BL` — общее количество битов в `s21_w_dec`, обычно 192).**

3. **Если бит `i` второго числа `dec2` равен 1:**
   
   - Добавляем текущее значение первого числа `mult` к результату (`tmp = wdec_sum(tmp, mult)`).
   - Сдвигаем первое число `mult` влево на одну позицию (`shift_l(mult)`).

4. **Возвращаем структуру `tmp`, содержащую результат умножения.**

### Пример с итерациями

Допустим, у нас есть две структуры `s21_w_dec`:

```c
s21_w_dec dec1 = {
    {0b00000010, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000},
    0,
    0
};
s21_w_dec dec2 = {
    {0b00000011, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000},
    0,
    0
};
```

Мы хотим умножить `dec1` и `dec2`.

#### Шаги:

1. **Инициализируем `tmp` с нулями.**

2. **Проходим по битам второго числа:**

   - Для `i = 0` (первый бит):
     - Бит равен 1 (`dec2.bits[0] = 0b00000011`).
     - `tmp = wdec_sum(tmp, mult)` (где `mult = dec1`), теперь `tmp.bits[0] = 0b00000010`.
     - Сдвигаем `mult` влево (`shift_l(mult)`), теперь `mult.bits[0] = 0b00000100`.

   - Для `i = 1` (второй бит):
     - Бит равен 1 (`dec2.bits[0] = 0b00000011`).
     - `tmp = wdec_sum(tmp, mult)`, теперь `tmp

.bits[0] = 0b00000110`.

3. **Возвращаем результат:**

Результат после всех итераций:

```c
tmp.bits[0] = 0b00000110; // 6 в десятичной системе
```

Это был результат умножения двух чисел: `2 * 3 = 6`.

Эти примеры показывают, как каждая функция манипулирует битами и числами на уровне побитовых операций, позволяя реализовать сложные операции с использованием простых логических и арифметических действий.